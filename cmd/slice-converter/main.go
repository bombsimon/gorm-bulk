package main

import (
	"bytes"
	"errors"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

const templateData = `// Code generated by slice-converter; DO NOT EDIT.
// See github.com/bombsimon/gorm-bulk
package {{.Package}}

{{ range $t := .TypeNames -}}
// {{$t}}PtrSliceToInterfaceSlice returns an interface slice with {{$t}}s.
func {{$t}}PtrSliceToInterfaceSlice(ts []*{{$t}}) []interface{} {
	var is = make([]interface{}, len(ts))

	for i := range ts {
		is[i] = ts[i]
	}

	return is
}

// {{$t}}SliceToInterfaceSlice returns an interface slice with {{$t}}s.
func {{$t}}SliceToInterfaceSlice(ts []{{$t}}) []interface{} {
	var is = make([]interface{}, len(ts))

	for i := range ts {
		is[i] = ts[i]
	}

	return is
}
{{ end }}
`

func main() {
	var (
		help    bool
		keyword string
	)

	flag.BoolVar(&help, "h", false, "Show this help text")
	flag.BoolVar(&help, "help", false, "")
	flag.StringVar(&keyword, "keyword", "TYPE-TO-INTERFACE", "Keyword to match to generate conversion function")
	flag.Parse()

	if help {
		flag.PrintDefaults()
		return
	}

	p := New(os.Getenv("GOFILE"), keyword)
	if err := p.GetTypesFromFile(); err != nil {
		panic(err)
	}

	if err := p.CreateFile(); err != nil {
		panic(err)
	}

	fmt.Printf("Generated slice to interface slice for %d types\n", len(p.TypeNames))
}

// Parser is the parser that will search a file for constants and add each
// constant as an enum.
type Parser struct {
	TypeNames []string
	File      string
	Keyword   string
	Package   string
}

// New will create a new parser to use for a given file.
func New(file, kw string) *Parser {
	return &Parser{
		Keyword: kw,
		File:    file,
	}
}

// GetTypesFromFile will read a file and pass the content to GetEnum()
func (p *Parser) GetTypesFromFile() error {
	fileData, err := ioutil.ReadFile(p.File)
	if err != nil {
		return err
	}

	return p.GetTypes(fileData)
}

// GetTypes will find all enum in one const block starting from the parsers
// LineStart.
func (p *Parser) GetTypes(fileData []byte) error {
	fset := token.NewFileSet()

	file, err := parser.ParseFile(fset, "", fileData, parser.ParseComments)
	if err != nil {
		return err
	}

	p.findStructTypes(file)

	if len(p.TypeNames) < 1 {
		return errors.New("no types found")
	}

	p.Package = file.Name.Name

	return nil
}

// CreateFile will create a file on disk with the enum found.
func (p *Parser) CreateFile() error {
	tmpl := template.Must(template.New("").Parse(templateData))
	buf := bytes.Buffer{}

	if err := tmpl.Execute(&buf, p); err != nil {
		return err
	}

	fileBytes, err := format.Source(buf.Bytes())
	if err != nil {
		return err
	}

	outputFile := filepath.Join(
		filepath.Dir(p.File),
		"types_to_if.gen.go",
	)

	if err := ioutil.WriteFile(outputFile, fileBytes, 0644); err != nil {
		return err
	}

	return nil
}

func (p *Parser) findStructTypes(f *ast.File) {
	for _, decl := range f.Decls {
		// Ensure the declaration is a GenDecl.
		gdecl, ok := decl.(*ast.GenDecl)
		if !ok {
			continue
		}

		if gdecl.Tok != token.TYPE {
			continue
		}

		var hasGoGenerate bool

		for _, doc := range gdecl.Doc.List {
			if strings.Contains(doc.Text, p.Keyword) {
				hasGoGenerate = true
				break
			}
		}

		if !hasGoGenerate {
			continue
		}

		for _, spec := range gdecl.Specs {
			ts, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}

			p.TypeNames = append(p.TypeNames, ts.Name.Name)
		}
	}
}

// vim: set ft=gohtmltmpl:
